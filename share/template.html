<!DOCTYPE html>
<html lang="en-US">
    <head>
        <title>Rails Model Visualizer</title>
        <meta charset="utf-8">
        <!--<link rel="stylesheet" type="text/css" href="<%= @css %>"/>
        <script src="<%= @d3 %>" charset="utf-8"></script>-->
        <link rel="stylesheet" type="text/css" href="../model-visualizer/share/main.css"/>
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
        <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    </head>

    <body>
        <%= @sidebar %>

        <div class="container">
            <div class="title"><%= @title %></div>
            <div class="inner-container">
                <!-- SVG will be inserted here -->
            </div>
        </div>

        <script>
            (function() {
                // Model data is inserted from visualizer.rb
                var data = <%= @models %>;
                var nodes = [];
                var links = [];
                var node;

                // Create node array and number each one
                var i = 0;
                for (var name in data) {
                    if (data.hasOwnProperty(name)) {
                        node = data[name];
                        node.node_number = i++;
                        nodes.push({
                            name: name,
                            group: 1,
                            schema_info: node.schema_info
                        });
                    }
                }

                // Create links array using associations
                for (var name in data) {
                    if (data.hasOwnProperty(name)) {
                        node = data[name];
                        for (var assn_type in node.associations) {
                            node.associations[assn_type].forEach(function(assn) {
                                if (assn in data) {
                                    links.push({
                                        source: node.node_number,
                                        target: data[assn].node_number,
                                        type: assn_type
                                    });
                                } else {
                                    console.log('ERROR: association not found. ' + name + ' -> ' + assn)
                                }
                            });
                        }
                    }
                }

                var container = document.getElementsByClassName("inner-container")[0];
                var width = container.clientWidth,
                    height = container.clientHeight;

                var svg = d3.select(".inner-container")
                            .append("svg")
                            .attr("width", width)
                            .attr("height", height);

                var force = d3.layout.force()
                              .size([width, height])
                              .nodes(d3.values(nodes))
                              .links(links)
                              .charge(-1000)
                              .linkDistance(200)
                              .start();

                var node_drag = d3.behavior.drag()
                  .on("dragstart", dragstart)
                  .on("drag", dragmove)
                  .on("dragend", dragend);

                function dragstart(d, i) {
                  force.stop() // stops auto positioning
                }

                function dragmove(d, i) {
                  d.px += d3.event.dx;
                  d.py += d3.event.dy;
                  d.x += d3.event.dx;
                  d.y += d3.event.dy;
                }

                function dragend(d, i) {
                  d.fixed = true; // set node to fixed so  orce doesn't include in auto positioning
                  force.resume();
                }

                function releasenode(d) {
                  d.fixed = false;
                }

                var markerWidth = 8,
                    markerHeight = 8,
                    cRadius = 30, // play with the cRadius value
                    refX = cRadius + (markerWidth / 2),
                    refY = -Math.sqrt(cRadius / 3),
                    maxNodeLabelSize = cRadius * .7,
                    minNodeLabelSize = cRadius * .5,
                    drSub = cRadius - refY;

                // build the arrow.
                svg.append("svg:defs")
                   .selectAll("marker")
                   .data(["belongs_to", "has_and_belongs_to_many", "has_many", "has_one"])      // Different link/path types can be defined here
                   .enter().append("svg:marker")    // This section adds in the arrows
                   .attr("id", function(d) {return d; })
                   .attr("viewBox", "0 -5 10 10")
                   .attr("refX", refX)
                   .attr("refY", refY)
                   .attr("markerWidth", markerWidth)
                   .attr("markerHeight", markerHeight)
                   .attr("orient", "auto")
                   .append("svg:path")
                   .attr("d", "M0,-5L10,0L0,5");

                // add the links and the arrows
                var path = svg.append("svg:g").selectAll("path")
                              .data(force.links())
                              .enter().append("svg:path")
                              .attr("class", function(d) {return "link " + d.type; })
                              .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

                var node = svg.append("g").selectAll(".node")
                  .data(nodes)
                  .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", cRadius)
                    .on("mouseover", mouseover)
                    .on("mouseout", mouseout)
                    .on('click', releasenode)
                    .call(node_drag)

                var text = svg.append("g").selectAll("text")
                  .data(force.nodes())
                  .enter().append("text")
                    .text(function(d) {return d.name;})
                    .attr("text-anchor", "middle")
                    .attr("class", "node-label")
                    //.style("font-size", "1px")
                    .each(getSize)
                    .style("font-size", function(d)
                      {console.log(d.scale); return d.scale + "px";})
                    //.attr("dy", function(d)
                      //{return (d.scale / 5) + "px";});

                /*// Create the node groups under svg
                var gnodes = svg.selectAll('g.gnode')
                                .data(nodes)
                                .enter()
                                .append('g')
                                .on("mouseover", mouseover)
                                .on("mouseout", mouseout)
                                .classed('gnode', true);

                // Add circle to each group
                node = gnodes.append("circle")
                             .attr("class", "node")
                             .attr("r", cRadius)
                             .call(force.drag);

                // Append labels to each group
                var labels = gnodes.append("text")
                                   .text(function(d) { return d.name; })
                                   .attr("text-anchor", "middle")
                                   .attr("class", "node-label")
                                   .style("font-size", "1px")
                                   .each(getSize)
                                   .style("font-size", function(d) { return d.scale + "px"; })
                                   .attr("dy", function(d) { return (d.scale / 5) + "px"; });*/

                // Show model attributes on hover
                node.append("title").text(function(d) {
                    var description = d.name + '\r\n';

                    for (var attr in d.schema_info) {
                        if (d.schema_info[attr].length > 0) {
                            description += '\r\n' + attr + ": " + d.schema_info[attr].join(', ');
                        }
                    }

                    return description;
                });

                // var legendRectSize = 18;
                // var legendSpacing = 4;

                // var color = d3.scale.category20b();

                // var legend = svg.selectAll('.legend')
                //   .data(force.links().domain())
                //   .enter()
                //   .append('g')
                //   .attr('class', 'legend')
                //   .attr('transform', function(d, i) {
                //     var height = legendRectSize + legendSpacing;
                //     var offset =  height * links.length / 2;
                //     var horz = -2 * legendRectSize;
                //     var vert = i * height - offset;
                //     return 'translate(' + horz + ',' + vert + ')';
                // });

                // legend.append('rect')
                //   .attr('width', legendRectSize)
                //   .attr('height', legendRectSize);
                //   // .style('fill', color)
                //   // .style('stroke', color);

                // legend.append('text')
                //   .attr('x', legendRectSize + legendSpacing)
                //   .attr('y', legendRectSize - legendSpacing)
                //   .text(function(d) { return d; });


                function getSize(d) {
                  var bbox = this.getBBox(),
                      margin = 3.0,
                      cbbox = this.parentNode.getBBox(),
                      scale = Math.min(cbbox.width/bbox.width, cbbox.height/bbox.height);
                  //console.log(bbox, cbbox, scale);
                  scale = Math.min(scale, maxNodeLabelSize);
                  //console.log(scale);
                  scale = Math.max(scale, minNodeLabelSize);
                  //console.log(scale);
                  d.scale = (scale - margin);
                }

                function mouseover() {
                  d3.select(this).select("circle").transition()
                      .duration(500)
                      .attr("r", function(d){
                        return cRadius * 1.1;
                      })
                      .style("fill", function(d) {
                         return "#90EE90";
                      })
                  d3.select(this).select('text').transition()
                      .duration(500)
                      .style("font-size", function(d) { return d.scale * 1.1; });
                }

                function mouseout() {
                  d3.select(this).select('text').transition()
                      .duration(500)
                      .style("font-size", function(d) { return d.scale; })
                  d3.select(this).select("circle").transition()
                      .duration(500)
                      .attr("r", function(d){
                        return cRadius;
                      })
                      .style("fill", function(d) {
                         return "#6495ED";
                      });
                }

                force.on("tick", function() {
                    path.attr("d", function(d) {
                      var dx = d.target.x - d.source.x,
                          dy = d.target.y - d.source.y,
                          dr = Math.sqrt(dx * dx + dy * dy);
                      return "M" +
                          d.source.x + "," +
                          d.source.y + "A" +
                          (dr - drSub) + "," + (dr - drSub) + " 0 0,1 " +
                          d.target.x + "," +
                          d.target.y;
                      });

                    // link.attr("x1", function(d) { return d.source.x; })
                    //     .attr("y1", function(d) { return d.source.y; })
                    //     .attr("x2", function(d) { return d.target.x; })
                    //     .attr("y2", function(d) { return d.target.y; });

                    // Translate the groups
                    node.attr("transform", transform);
                    text.attr("transform", transform);
                    /*node.attr("transform", function(d) {
                        return 'translate(' + [d.x, d.y] + ')';
                    });
                    d3.selectAll("text").attr("x", function (d) {
                      return d.x;
                    })
                      .attr("y", function (d) {
                      return d.y;
                    });*/
                    node.each(collide(0.5));
                    // node.attr("cx", function(d) { return d.x; })
                    //     .attr("cy", function(d) { return d.y; });
                });

                function transform(d) {
                  return "translate(" + d.x + "," + d.y + ")";
                }

                //Code for collision avoidance
                var padding = 1, // separation between circles
                    radius=cRadius;
                function collide(alpha) {
                  var quadtree = d3.geom.quadtree(nodes);
                  return function(d) {
                    var rb = 2*radius + padding,
                        nx1 = d.x - rb,
                        nx2 = d.x + rb,
                        ny1 = d.y - rb,
                        ny2 = d.y + rb;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                      if (quad.point && (quad.point !== d)) {
                        var x = d.x - quad.point.x,
                            y = d.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y);
                          if (l < rb) {
                          l = (l - rb) / l * alpha;
                          d.x -= x *= l;
                          d.y -= y *= l;
                          quad.point.x += x;
                          quad.point.y += y;
                         }
                      }
                      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                  };
                }

                // Search functionality for sidebar
                var searchdiv = document.getElementsByClassName('sidebar')[0].firstChild;
                var searchfield = searchdiv.firstChild;
                searchfield.oninput = function() {
                    var sidebarentries = document.getElementsByClassName('model');
                    var search = searchfield.value.toLowerCase();
                    for (var i = 0; i < sidebarentries.length; i++) {
                        var entry = sidebarentries[i];
                        var html = entry.innerHTML.toLowerCase();
                        if (html.indexOf(search) == -1) {
                            entry.style.display = 'none';
                        } else {
                            entry.style.display = 'block';
                        }
                    }
                }

                // Highlight node on click. Must be global.
                window.highlightNode = function(name) {
                    // Dim all links and all nodes but the one with the given name
                    svg.selectAll(".node").filter(function (d, i) {
                        return d.name != name;
                    }).style("opacity", "0.1");
                    svg.selectAll(".link").style("opacity", "0.1");

                    // TODO: display tooltip and keep everything else dimmed to undim later
                    d3.selectAll(".node, .link").transition()
                                                 .duration(1500)
                                                 .style("opacity", "1");
                }
            })();
        </script>
    </body>
</html>