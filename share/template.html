<!DOCTYPE html>
<html lang="en-US">
    <head>
        <title>Rails Model Visualizer</title>
        <meta charset="utf-8">
        <!-- d3 3.5.5 included from gem directory -->
        <!--<script src="<%= @d3 %>" charset="utf-8"></script>-->
        <script type='text/javascript' src="http://code.jquery.com/jquery-1.11.3.min.js"> </script>
        <link href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css" rel="Stylesheet"></link>
        <script src="http://code.jquery.com/ui/1.10.2/jquery-ui.js" ></script>
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
        <script type='text/javascript' src="http://bost.ocks.org/mike/fisheye/fisheye.js?0.0.3"> </script>
    </head>

    <body>
        <script>
                            var width = window.innerWidth,
                    height = window.innerHeight;
            var svg = d3.select("body")
                            .append("svg")
                            .attr("width", width)
                            .attr("height", height);
            (function() {
                // Model data is inserted from visualizer.rb
                var data = <%= @models %>;
                var nodes = [];
                var links = [];
                var node;

                // Create node array and number each one
                var i = 0;
                for (var name in data) {
                    if (data.hasOwnProperty(name)) {
                        node = data[name];
                        node.node_number = i++;
                        nodes.push({
                            name: name,
                            group: 1,
                            schema_info: node.schema_info
                        });
                    }
                }

                // Create links array using associations
                for (var name in data) {
                    if (data.hasOwnProperty(name)) {
                        node = data[name];
                        for (var assn_type in node.associations) {
                            node.associations[assn_type].forEach(function(assn) {
                                links.push({
                                    source: node.node_number,
                                    target: data[assn].node_number,
                                    type: assn_type
                                });
                            });
                        }
                    }
                }

                //var width = window.innerWidth,
                    //height = window.innerHeight;

                var color = d3.scale.category20();

                var force = d3.layout
                              .force()
                              .charge(-120)
                              .linkDistance(30)
                              .size([width, height]);

                //Pin down node on drag
                var node_drag = d3.behavior.drag()
                    .on("dragstart", dragstart)
                    .on("drag", dragmove)
                    .on("dragend", dragend);
                function dragstart(d, i) {
                    force.stop() // stops the force auto positioning before you start dragging
                }
                function dragmove(d, i) {
                    d.px += d3.event.dx;
                    d.py += d3.event.dy;
                    d.x += d3.event.dx;
                    d.y += d3.event.dy;
                }
                function dragend(d, i) {
                    d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
                    force.resume();
                }
                function releasenode(d) {
                    d.fixed = false; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
                    //force.resume();
                }

                /*var svg = d3.select("body")
                            .append("svg")
                            .attr("width", width)
                            .attr("height", height);*/

                force.nodes(nodes)
                     .links(links)
                     .start();

                var link = svg.selectAll(".link")
                              .data(links)
                              .enter().append("line")
                              .attr("class", "link")
                              //Insert directed links
                              .style("marker-end",  "url(#suit)") 
                              .style("stroke-width", function(d) { return Math.sqrt(d.value); })
                              .style("stroke", function(d) {
                                return "#999";
                              })
                              //Insert colored links
                              /*.style("stroke", function(d) {
                                  switch(d.type) {
                                      case "belongs_to":
                                          return "#000";
                                      case "has_and_belongs_to_many":
                                          return "#f00";
                                      case "has_many":
                                          return "#0f0";
                                      case "has_one":
                                          return "#00f";
                                      default:
                                          return "#999";
                                  }
                              })*/;

                var node = svg.selectAll(".node")
                    .data(nodes)
                    .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", 8)
                    .style("fill", function (d) {
                    return color(d.group);
                })
                    .on('dblclick', connectedNodes)
                    .on('click', releasenode)
                    .call(node_drag);
                    

                //This adds labels to the nodes
                /*
                // Create the node groups under svg
                var gnodes = svg.selectAll('g.gnode')
                                .data(nodes)
                                .enter()
                                .append('g')
                                .classed('gnode', true);

                // Add circle to each group
                node = gnodes.append("circle")
                             .attr("class", "node")
                             .attr("r", 8)
                             .style("fill", function(d) { return color(d.group); })
                             .call(force.drag);

                // Append labels to each group
                var labels = gnodes.append("text")
                                   .text(function(d) { return d.name; });
                */

                // Show model attributes on hover
                node.append("title").text(function(d) {
                    var description = d.name + '\r\n';

                    for (var attr in d.schema_info) {
                        if (d.schema_info[attr].length > 0) {
                            description += '\r\n' + attr + ": " + d.schema_info[attr].join(', ');
                        }
                    }

                    return description;
                });

                force.on("tick", function() {
                    link.attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });

                    // Needed to add labels to nodes
                    /*gnodes.attr("transform", function(d) {
                        return 'translate(' + [d.x, d.y] + ')';
                    });*/
                    node.attr("cx", function(d) { return d.x; })
                        .attr("cy", function(d) { return d.y; });
                    node.each(collide(0.5));
                });

                //Adding directed links
                svg.append("defs").selectAll("marker")
                  .data(["suit", "licensing", "resolved"])
                .enter().append("marker")
                  .attr("id", function(d) { return d; })
                  .attr("viewBox", "0 -5 10 10")
                  .attr("refX", 25)
                  .attr("refY", 0)
                  .attr("markerWidth", 6)
                  .attr("markerHeight", 6)
                  .attr("orient", "auto")
                .append("path")
                  .attr("d", "M0,-5L10,0L0,5 L10,0 L0, -5")
                  .style("stroke", "#999");

                /*//Code to change number of links between nodes, not working yet. 

                nodesRec=JSON.parse(JSON.stringify(nodes));
                linksRec=JSON.parse(JSON.stringify(links));

                //Change threshold
                function threshold(thresh) {
                    links.splice(0, links.length);
                    for (var i = 0; i < linksRec.length; i++) {
                      if (linksRec[i].value > thresh) {links.push(linksRec[i]);}
                    }
                    restart();
                }
                //Reset graphics after a change
                function restart() {
                  link = link.data(links);
                  link.exit().remove();
                  link.enter().insert("line", ".node").attr("class", "link");
                  node = node.data(nodes);
                  node.enter().insert("circle", ".cursor").attr("class", "node").attr("r", 5).call(force.drag);
                  force.start();
                }

                <form>
                  <h3> Link threshold 0 <input type="range" id="thersholdSlider" name="points" value = 0 min="0" max="10" onchange="threshold(this.value)"> 10 </h3>
                </form>

                //Add '.on("dblclick", threshold);' to SVG var'*/

                //Code for collision avoidance
                var padding = 1, // separation between circles
                    radius=8;

                function collide(alpha) {
                  var quadtree = d3.geom.quadtree(nodes);
                  return function(d) {
                    var rb = 2*radius + padding,
                        nx1 = d.x - rb,
                        nx2 = d.x + rb,
                        ny1 = d.y - rb,
                        ny2 = d.y + rb;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                      if (quad.point && (quad.point !== d)) {
                        var x = d.x - quad.point.x,
                            y = d.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y);
                          if (l < rb) {
                          l = (l - rb) / l * alpha;
                          d.x -= x *= l;
                          d.y -= y *= l;
                          quad.point.x += x;
                          quad.point.y += y;
                        }
                      }
                      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                  };
                }

                /*//Fisheye, activate!!!
                var fisheye = d3.fisheye.circular()
                      .radius(120);
                svg.on("mousemove", function() {
                      force.stop();
                      fisheye.focus(d3.mouse(this));
                      d3.selectAll("circle").each(function(d) { d.fisheye = fisheye(d); })
                          .attr("cx", function(d) { return d.fisheye.x; })
                          .attr("cy", function(d) { return d.fisheye.y; })
                          .attr("r", function(d) { return d.fisheye.z * 8; });
                      link.attr("x1", function(d) { return d.source.fisheye.x; })
                          .attr("y1", function(d) { return d.source.fisheye.y; })
                          .attr("x2", function(d) { return d.target.fisheye.x; })
                          .attr("y2", function(d) { return d.target.fisheye.y; });
                    });*/

                //Activate highlighting neighbors on double click
                var toggle = 0;
                //Array for neighbors
                var linkedByIndex = {};
                for (i = 0; i < nodes.length; i++) {
                    linkedByIndex[i + "," + i] = 1;
                };
                links.forEach(function (d) {
                    linkedByIndex[d.source.index + "," + d.target.index] = 1;
                });
                //Are pair neighbors?
                function neighboring(a, b) {
                    return linkedByIndex[a.index + "," + b.index];
                }
                function connectedNodes() {
                    if (toggle == 0) {
                        //Fade out non-neighbors
                        d = d3.select(this).node().__data__;
                        node.style("opacity", function (o) {
                            return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
                        });
                        link.style("opacity", function (o) {
                            return d.index==o.source.index | d.index==o.target.index ? 1 : 0.1;
                        });
                        toggle = 1;
                    } else {
                        node.style("opacity", 1);
                        link.style("opacity", 1);
                        toggle = 0;
                    }
                }

                //Searchbox! :D
                var optArray = [];
                for (var i = 0; i < nodes.length - 1; i++) {
                    optArray.push(nodes[i].name);
                }
                optArray = optArray.sort();
                $(document).ready(function () {
                    $("#search").autocomplete({
                        source: optArray
                    });
                });
              })();
              function searchNode() {
                    //find the node
                    var selectedVal = document.getElementById('search').value;
                    var node = svg.selectAll(".node");
                    if (selectedVal == "none") {
                        node.style("stroke", "white").style("stroke-width", "1");
                    } else {
                        var selected = node.filter(function (d, i) {
                            return d.name != selectedVal;
                        });
                        selected.style("opacity", "0");
                        var link = svg.selectAll(".link")
                        link.style("opacity", "0");
                        d3.selectAll(".node, .link").transition()
                            .duration(5000)
                            .style("opacity", 1);
                    }
                }
        </script>
        <div class="ui-widget">
           <input id="search">
            <button type="button" onclick="searchNode()">Search</button>
        </div>
    </body>
</html>